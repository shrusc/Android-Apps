AtomicBoolean circlesInMotion = new AtomicBoolean(true);

        Thread moveCirclesThread = new Thread(new Runnable(){
            public void run(){
                while(circlesInMotion.get()){
                    //Log.d(VIEW_LOG_TAG, "Touching Down");
                    //maybe sleep some times to not polute your logcat
                    for (Circle circle : circlesArray) {
                        if (circle.circleInMotion) {
                            circle.centerX += circle.velocityX;
                            circle.centerY += circle.velocityY;
                            if (circle.centerX + circle.radius > screenWidth || circle.centerX - circle.radius < 0) {
                                circle.velocityX = circle.velocityX * -1;
                                //circle.centerX = screenWidth - circle.radius;
                            }
                            if (circle.centerY + circle.radius > screenHeight || circle.centerY - circle.radius < 0) {
                                circle.velocityY = circle.velocityY * -1;
                                //circle.centerY = screenHeight - circle.radius;
                            }
                        }
                    }
                    postInvalidate();//invalidate();
                    try{
                        Thread.sleep(1000);
                    } catch(Exception e){

                    }
                }
                Log.d(VIEW_LOG_TAG, "Not Touching");
            }
        });

// moveCirclesThread.start();

 /*if(null != touchedCircle) {
                    velocity.addMovement(event);
                    velocity.computeCurrentVelocity(1000);
                    Log.i("rew", "X vel " + velocity.getXVelocity() + " Y vel " + velocity.getYVelocity());
                    touchedCircle.setVelocity(velocity.getXVelocity()/4,velocity.getYVelocity()/4);
                    //touchedCircle.centerY += velocity.getYVelocity()/100;
                    //invalidate();
                    circleMovingHandler.removeCallbacks(MoveCircle);
                    circleMovingHandler.postDelayed(MoveCircle, 1000);
                }*/


/*public void bounceCircles (Circle circle) {
            float newVelX1 = (this.velocityX * (this.getMass() - circle.getMass()) +
                    (2 * circle.getMass() * circle.velocityX)) / (this.getMass() + circle.getMass());
            float newVelY1 = (this.velocityY * (this.getMass() - circle.getMass()) +
                    (2 * circle.getMass() * circle.velocityY)) / (this.getMass() + circle.getMass());
            float newVelX2 = (circle.velocityX * (circle.getMass() - this.getMass()) +
                    (2 * this.getMass() * this.velocityX)) / (this.getMass() + circle.getMass());
            float newVelY2 = (circle.velocityY * (circle.getMass() - this.getMass()) +
                    (2 * this.getMass() * this.velocityY)) / (this.getMass() + circle.getMass());

            this.velocityX = newVelX1;
            this.velocityY = newVelY1;
            circle.velocityX = newVelX2;
            circle.velocityY = newVelY2;

            //Move the balls if they are stationary
            if(this.velocityX != 0 || this.velocityY != 0)
                this.circleInMotion = true;
            if(circle.velocityX != 0 || circle.velocityY !=0)
                circle.circleInMotion = true;

        }*/


private boolean isNotOverlappingOtherCircles(float x, float y, float radius) {
        boolean overlap = true;
        for (Circle circle : circlesArray) {
            if(!circle.circleToGrow) {
                double distance = Math.sqrt((circle.centerX-x)*(circle.centerX-x) +
                        (circle.centerY-y)*(circle.centerY-y));
                if(distance < circle.radius + radius) {
                    overlap = false;
                    break;
                }
            }
        }
        return overlap;
    }